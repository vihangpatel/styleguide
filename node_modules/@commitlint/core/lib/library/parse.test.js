'use strict';

var _importFrom = require('import-from');

var _importFrom2 = _interopRequireDefault(_importFrom);

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _parse = require('./parse');

var _parse2 = _interopRequireDefault(_parse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _ava2.default)('throws when called without params', function (t) {
	return new Promise(function ($return, $error) {
		var error;
		return Promise.resolve(t.throws((0, _parse2.default)())).then(function ($await_1) {
			try {
				error = $await_1;
				t.is(error.message, 'Expected a raw commit');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('throws when called with empty message', function (t) {
	return new Promise(function ($return, $error) {
		var error;
		return Promise.resolve(t.throws((0, _parse2.default)())).then(function ($await_2) {
			try {
				error = $await_2;
				t.is(error.message, 'Expected a raw commit');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('returns object with raw message', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual;

		message = 'type(scope): subject';
		return Promise.resolve((0, _parse2.default)(message)).then(function ($await_3) {
			try {
				actual = $await_3;
				t.is(actual.raw, message);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('calls parser with message and passed options', function (t) {
	return new Promise(function ($return, $error) {
		var message;

		message = 'message';

		return Promise.resolve((0, _parse2.default)(message, function (m) {
			t.is(message, m);
			return {};
		})).then(function ($await_4) {
			try {
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('passes object up from parser function', function (t) {
	return new Promise(function ($return, $error) {
		var message, result, actual;

		message = 'message';
		result = {};
		return Promise.resolve((0, _parse2.default)(message, function () {
			return result;
		})).then(function ($await_5) {
			try {
				actual = $await_5;
				t.is(actual, result);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('returns object with expected keys', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual, expected;

		message = 'message';
		return Promise.resolve((0, _parse2.default)(message)).then(function ($await_6) {
			try {
				actual = $await_6;
				expected = {
					body: null,
					footer: null,
					header: 'message',
					mentions: [],
					merge: null,
					notes: [],
					raw: 'message',
					references: [],
					revert: null,
					scope: null,
					subject: null,
					type: null
				};
				t.deepEqual(actual, expected);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('uses angular grammar', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual, expected;

		message = 'type(scope): subject';
		return Promise.resolve((0, _parse2.default)(message)).then(function ($await_7) {
			try {
				actual = $await_7;
				expected = {
					body: null,
					footer: null,
					header: 'type(scope): subject',
					mentions: [],
					merge: null,
					notes: [],
					raw: 'type(scope): subject',
					references: [],
					revert: null,
					scope: 'scope',
					subject: 'subject',
					type: 'type'
				};
				t.deepEqual(actual, expected);
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('uses custom opts parser', function (t) {
	return new Promise(function ($return, $error) {
		var message, changelogOpts, actual, expected;

		message = 'type(scope)-subject';
		return Promise.resolve((0, _importFrom2.default)(process.cwd(), './fixtures/parser-preset/conventional-changelog-custom')).then(function ($await_8) {
			try {
				changelogOpts = $await_8;
				return Promise.resolve((0, _parse2.default)(message, undefined, changelogOpts.parserOpts)).then(function ($await_9) {
					try {
						actual = $await_9;
						expected = {
							body: null,
							footer: null,
							header: 'type(scope)-subject',
							mentions: [],
							merge: null,
							notes: [],
							raw: 'type(scope)-subject',
							references: [],
							revert: null,
							scope: 'scope',
							subject: 'subject',
							type: 'type'
						};
						t.deepEqual(actual, expected);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('supports scopes with /', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual;

		message = 'type(some/scope): subject';
		return Promise.resolve((0, _parse2.default)(message)).then(function ($await_10) {
			try {
				actual = $await_10;
				t.is(actual.scope, 'some/scope');
				t.is(actual.subject, 'subject');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('ignores comments', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual;

		message = 'type(some/scope): subject\n# some comment';
		return Promise.resolve((0, _parse2.default)(message)).then(function ($await_11) {
			try {
				actual = $await_11;
				t.is(actual.body, null);
				t.is(actual.footer, null);
				t.is(actual.subject, 'subject');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('registers inline #', function (t) {
	return new Promise(function ($return, $error) {
		var message, actual;

		message = 'type(some/scope): subject #reference\n# some comment\nthings #reference';
		return Promise.resolve((0, _parse2.default)(message)).then(function ($await_12) {
			try {
				actual = $await_12;
				t.is(actual.subject, 'subject #reference');
				t.is(actual.body, 'things #reference');
				return $return();
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});
//# sourceMappingURL=parse.test.js.map