'use strict';

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _test = require('@commitlint/test');

var _ava = require('ava');

var _ava2 = _interopRequireDefault(_ava);

var _execa = require('execa');

var _execa2 = _interopRequireDefault(_execa);

var _lodash = require('lodash');

var _sander = require('sander');

var sander = _interopRequireWildcard(_sander);

var _stringToStream = require('string-to-stream');

var _stringToStream2 = _interopRequireDefault(_stringToStream);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var bin = _path2.default.join(__dirname, './cli.js');

var cli = function cli(args, options) {
	return function () {
		var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

		var c = (0, _execa2.default)(bin, args, {
			capture: ['stdout'],
			cwd: options.cwd,
			env: options.env
		});
		(0, _stringToStream2.default)(input).pipe(c.stdin);
		return c.catch(function (err) {
			return err;
		});
	};
};

(0, _ava2.default)('should throw when called without [input]', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_1) {
			try {
				cwd = $await_1;
				return Promise.resolve(cli([], { cwd })()).then(function ($await_2) {
					try {
						actual = $await_2;
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should reprint input from stdin', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_3) {
			try {
				cwd = $await_3;
				return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_4) {
					try {
						actual = $await_4;
						t.true(actual.stdout.includes('foo: bar'));
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should produce no success output with --quiet flag', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_5) {
			try {
				cwd = $await_5;
				return Promise.resolve(cli(['--quiet'], { cwd })('foo: bar')).then(function ($await_6) {
					try {
						actual = $await_6;
						t.is(actual.stdout, '');
						t.is(actual.stderr, '');
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should produce no success output with -q flag', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_7) {
			try {
				cwd = $await_7;
				return Promise.resolve(cli(['-q'], { cwd })('foo: bar')).then(function ($await_8) {
					try {
						actual = $await_8;
						t.is(actual.stdout, '');
						t.is(actual.stderr, '');
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should succeed for input from stdin without rules', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/empty')).then(function ($await_9) {
			try {
				cwd = $await_9;
				return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_10) {
					try {
						actual = $await_10;
						t.is(actual.code, 0);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should fail for input from stdin with rule from rc', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_11) {
			try {
				cwd = $await_11;
				return Promise.resolve(cli([], { cwd })('foo: bar')).then(function ($await_12) {
					try {
						actual = $await_12;
						t.true(actual.stdout.includes('type must not be one of [foo]'));
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should fail for input from stdin with rule from js', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/extends-root')).then(function ($await_13) {
			try {
				cwd = $await_13;
				return Promise.resolve(cli(['--extends', './extended'], { cwd })('foo: bar')).then(function ($await_14) {
					try {
						actual = $await_14;
						t.true(actual.stdout.includes('type must not be one of [foo]'));
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should produce no error output with --quiet flag', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_15) {
			try {
				cwd = $await_15;
				return Promise.resolve(cli(['--quiet'], { cwd })('foo: bar')).then(function ($await_16) {
					try {
						actual = $await_16;
						t.is(actual.stdout, '');
						t.is(actual.stderr, '');
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should produce no error output with -q flag', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/simple')).then(function ($await_17) {
			try {
				cwd = $await_17;
				return Promise.resolve(cli(['-q'], { cwd })('foo: bar')).then(function ($await_18) {
					try {
						actual = $await_18;
						t.is(actual.stdout, '');
						t.is(actual.stderr, '');
						t.is(actual.code, 1);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should work with husky commitmsg hook and git commit', function () {
	return new Promise(function ($return, $error) {
		var cwd;
		return Promise.resolve(_test.git.bootstrap('fixtures/husky/integration')).then(function ($await_19) {
			try {
				cwd = $await_19;
				return Promise.resolve(writePkg({ scripts: { commitmsg: `${bin} -e` } }, { cwd })).then(function ($await_20) {
					try {
						return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_21) {
							try {
								return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_22) {
									try {
										return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"chore: this should work"'], { cwd })).then(function ($await_23) {
											try {
												return $return();
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should work with husky commitmsg hook in sub packages', function () {
	return new Promise(function ($return, $error) {
		var upper, cwd;
		return Promise.resolve(_test.git.bootstrap('fixtures/husky')).then(function ($await_24) {
			try {
				upper = $await_24;
				cwd = _path2.default.join(upper, 'integration');
				return Promise.resolve(writePkg({ scripts: { commitmsg: `${bin} -e` } }, { cwd: upper })).then(function ($await_25) {
					try {
						return Promise.resolve((0, _execa2.default)('npm', ['install'], { cwd })).then(function ($await_26) {
							try {
								return Promise.resolve((0, _execa2.default)('git', ['add', 'package.json'], { cwd })).then(function ($await_27) {
									try {
										return Promise.resolve((0, _execa2.default)('git', ['commit', '-m', '"chore: this should work"'], { cwd })).then(function ($await_28) {
											try {
												return $return();
											} catch ($boundEx) {
												return $error($boundEx);
											}
										}.bind(this), $error);
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up parser preset and fail accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset')).then(function ($await_29) {
			try {
				cwd = $await_29;
				return Promise.resolve(cli(['--parser-preset', './parser-preset'], { cwd })('type(scope): subject')).then(function ($await_30) {
					try {
						actual = $await_30;
						t.is(actual.code, 1);
						t.true(actual.stdout.includes('message may not be empty [subject-empty]'));
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up parser preset and succeed accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var cwd, actual;
		return Promise.resolve(_test.git.bootstrap('fixtures/parser-preset')).then(function ($await_31) {
			try {
				cwd = $await_31;
				return Promise.resolve(cli(['--parser-preset', './parser-preset'], { cwd })('----type(scope): subject')).then(function ($await_32) {
					try {
						actual = $await_32;
						t.is(actual.code, 0);
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up config from outside git repo and fail accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_33) {
			try {
				outer = $await_33;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_34) {
					try {
						cwd = $await_34;

						return Promise.resolve(cli([], { cwd })('inner: bar')).then(function ($await_35) {
							try {
								actual = $await_35;
								t.is(actual.code, 1);
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up config from outside git repo and succeed accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/outer-scope')).then(function ($await_36) {
			try {
				outer = $await_36;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_37) {
					try {
						cwd = $await_37;

						return Promise.resolve(cli([], { cwd })('outer: bar')).then(function ($await_38) {
							try {
								actual = $await_38;
								t.is(actual.code, 0);
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up config from inside git repo with precedence and succeed accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/inner-scope')).then(function ($await_39) {
			try {
				outer = $await_39;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_40) {
					try {
						cwd = $await_40;

						return Promise.resolve(cli([], { cwd })('inner: bar')).then(function ($await_41) {
							try {
								actual = $await_41;
								t.is(actual.code, 0);
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

(0, _ava2.default)('should pick up config from inside git repo with precedence and fail accordingly', function (t) {
	return new Promise(function ($return, $error) {
		var outer, cwd, actual;
		return Promise.resolve(_test.fix.bootstrap('fixtures/inner-scope')).then(function ($await_42) {
			try {
				outer = $await_42;
				return Promise.resolve(_test.git.init(_path2.default.join(outer, 'inner-scope'))).then(function ($await_43) {
					try {
						cwd = $await_43;

						return Promise.resolve(cli([], { cwd })('outer: bar')).then(function ($await_44) {
							try {
								actual = $await_44;
								t.is(actual.code, 1);
								return $return();
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
});

function writePkg(payload, options) {
	return new Promise(function ($return, $error) {
		var pkgPath, pkg, result;

		pkgPath = _path2.default.join(options.cwd, 'package.json');
		return Promise.resolve(sander.readFile(pkgPath)).then(function ($await_45) {
			try {
				pkg = JSON.parse($await_45);
				result = (0, _lodash.merge)(pkg, payload);
				return Promise.resolve(sander.writeFile(pkgPath, JSON.stringify(result, null, '  '))).then(function ($await_46) {
					try {
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}
//# sourceMappingURL=cli.test.js.map