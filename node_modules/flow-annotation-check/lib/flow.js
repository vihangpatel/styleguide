'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.genForceErrors = exports.genCountVisibleFiles = exports.genCheckFlowStatus = undefined;

var _core = require('./core');

var _promisified = require('./promisified');

var FLOW_MODE = {
  FLOW: 'flow',
  FLOW_WEAK: 'flow weak',
  NO_FLOW: 'no flow'
};

function astToFlowStatus(ast) {
  for (var i = 0; i < 10; i++) {
    var comment = ast.comments[i];
    if (!comment) {
      return FLOW_MODE.NO_FLOW;
    }
    switch (comment.type) {
      case 'Line':
        var trimmedLine = comment.value.trim();
        if (trimmedLine == '@flow') {
          return FLOW_MODE.FLOW;
        } else if (trimmedLine == '@flow weak') {
          return FLOW_MODE.FLOW_WEAK;
        }
        break;
      case 'Block':
        var lines = comment.value.split('\n').map(function (line) {
          return line.trim().replace(/^\*/, '').trim();
        });

        if (lines.indexOf('@flow') >= 0) {
          return FLOW_MODE.FLOW;
        } else if (lines.indexOf('@flow weak') >= 0) {
          return FLOW_MODE.FLOW_WEAK;
        }
        break;
      default:
        throw new Error('Unknown comment type', comment.type, comment);
    }
  }
  return FLOW_MODE.NO_FLOW;
}

function genCheckFlowStatus(flowPath, file) {
  var options = { maxBuffer: Infinity };

  return (0, _promisified.exec)(flowPath + ' ast ' + (0, _promisified.escapeShell)(file), options).then(function (_ref) {
    var stdout = _ref.stdout,
        stderr = _ref.stderr;

    if (stderr) {
      throw new Error(stderr);
    }
    return JSON.parse(String(stdout));
  }).then(astToFlowStatus);
}

function genCountVisibleFiles(flowPath, cwd) {
  var options = {
    maxBuffer: Infinity
  };

  return (0, _promisified.exec)(flowPath + ' ls ' + (0, _promisified.escapeShell)(cwd) + ' | wc -l', options).then(function (_ref2) {
    var stdout = _ref2.stdout,
        stderr = _ref2.stderr;

    if (stderr) {
      throw new Error(stderr);
    }
    return parseInt(String(stdout).trim(), 10);
  });
}

function genForceErrors(cwd, files, flags) {
  var flowCheck = flags.absolute ? ['check', '--json', '--show-all-errors', cwd] : ['check', '--json', '--show-all-errors', '--strip-root', cwd];
  var options = {
    maxBuffer: Infinity
  };
  var ERROR_STATEMENT = 'const FLOW_ANNOTATION_CHECK_INJECTED_ERROR: string = null;';

  return Promise.all(files.map(function (file) {
    return (0, _promisified.append)(file, ERROR_STATEMENT);
  })).then(function () {
    return (0, _promisified.execFile)(flags.flow_path, flowCheck, options).then(function (_ref3) {
      var stdout = _ref3.stdout,
          stderr = _ref3.stderr;
      return JSON.parse(String(stdout));
    }).catch(function (_ref4) {
      var error = _ref4.error,
          stdout = _ref4.stdout,
          stderr = _ref4.stderr;

      try {
        return JSON.parse(String(stdout));
      } catch (e) {
        return {};
      }
    });
  }).then(function (checkResult) {
    return Promise.all(files.map(function (file) {
      return (0, _promisified.truncate)(file, ERROR_STATEMENT);
    })).then(function (_) {
      if (checkResult.errors) {
        return (0, _core.unique)((0, _core.flatten)(checkResult.errors.map(function (entry) {
          return entry.message.map(function (message) {
            return message.path;
          });
        })).filter(function (_) {
          return _;
        }));
      }
      return [];
    });
  });
}

exports.genCheckFlowStatus = genCheckFlowStatus;
exports.genCountVisibleFiles = genCountVisibleFiles;
exports.genForceErrors = genForceErrors;