'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveArgs = exports.main = exports.getParser = exports.run = undefined;

var _flowAnnotationCheck = require('./flow-annotation-check');

var _flowAnnotationCheck2 = _interopRequireDefault(_flowAnnotationCheck);

var _loadPkg = require('load-pkg');

var _loadPkg2 = _interopRequireDefault(_loadPkg);

var _package = require('../package.json');

var _package2 = _interopRequireDefault(_package);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _argparse = require('argparse');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_FLAGS = {
  absolute: false,
  allow_weak: false,
  exclude: ['+(node_modules|build|flow-typed)/**/*.js'],
  flow_path: 'flow',
  include: ['**/*.js'],
  root: '.'
};

function printDefault(value) {
  return '(default: `' + JSON.stringify(value) + '`)';
}

function getParser() {
  var parser = new _argparse.ArgumentParser({
    addHelp: true,
    version: _package2.default.version
  });

  parser.addArgument(['-f', '--flow-path'], {
    action: 'store',
    help: 'The path to the flow command. ' + printDefault(DEFAULT_FLAGS.flow_path)
  });
  parser.addArgument(['-a', '--absolute'], {
    action: 'storeTrue',
    help: 'Report absolute path names. ' + printDefault(DEFAULT_FLAGS.absolute)
  });
  parser.addArgument(['--allow-weak'], {
    action: 'storeTrue',
    help: 'Consider `@flow weak` as a accepable annotation. See https://flowtype.org/docs/existing.html#weak-mode for reasons why this should only be used temporarily. ' + printDefault(DEFAULT_FLAGS.allow_weak)
  });
  parser.addArgument(['-i', '--include'], {
    action: 'append',
    help: 'Glob for files to include. Can be set multiple times. ' + printDefault(DEFAULT_FLAGS.include)
  });
  parser.addArgument(['-x', '--exclude'], {
    action: 'append',
    help: 'Glob for files to exclude. Can be set multiple times. ' + printDefault(DEFAULT_FLAGS.exclude)
  });
  parser.addArgument(['--validate'], {
    action: 'storeTrue',
    help: 'Run in validation mode. This injects errors into globbed files and checks the flow-annotation status'
  });
  parser.addArgument(['root'], {
    defaultValue: '.',
    help: 'The root directory to glob files from. ' + printDefault(DEFAULT_FLAGS.root),
    nargs: '?'
  });

  return parser;
}

function getPackageJsonArgs(root, defaults) {
  var pkg = _loadPkg2.default.sync(_path2.default.resolve(root || defaults.root));
  if (pkg && pkg['flow-annotation-check']) {
    return resolveArgs(pkg['flow-annotation-check'], defaults);
  }
  return defaults;
}

function resolveArgs(args, defaults) {
  return {
    absolute: args.absolute || defaults.absolute,
    allow_weak: args.allow_weak || defaults.allow_weak,
    exclude: args.exclude || defaults.exclude,
    flow_path: args.flow_path || defaults.flow_path,
    include: args.include || defaults.include,
    root: _path2.default.resolve(args.root || defaults.root)
  };
}

function main(flags) {
  var command = flags.validate ? 'validate' : 'report';

  if (process.env.VERBOSE) {
    console.log('Invoking:', { command: command, flags: flags });
  }

  switch (command) {
    case 'validate':
      (0, _flowAnnotationCheck.genValidate)(flags.root, flags).then(function (report) {
        return printValidationReport(report, flags);
      }).catch(function (error) {
        console.log('Validate error:', error);
        process.exitCode = 2;
      });
      break;
    default:
      (0, _flowAnnotationCheck2.default)(flags.root, flags).then(function (report) {
        return printStatusReport(report, flags);
      }).catch(function (error) {
        console.log('Report error:', error);
        process.exitCode = 2;
      });
      break;
  }
}

function printStatusReport(report, flags) {
  report.forEach(function (entry) {
    console.log(entry.status + '\t' + entry.file);
  });

  var noFlowFiles = report.filter(function (entry) {
    return entry.status == 'no flow';
  });
  var weakFlowFiles = report.filter(function (entry) {
    return entry.status == 'flow weak';
  });
  var failingFileCount = flags.allow_weak ? noFlowFiles.length : noFlowFiles.length + weakFlowFiles.length;
  process.exitCode = failingFileCount ? 1 : 0;
}

function printValidationReport(report, flags) {
  if (process.env.VERBOSE) {
    console.log('All Entries');
    report.forEach(function (entry) {
      console.log((entry.isValid ? 'valid' : 'invalid') + '\t' + entry.file);
    });
    console.log('');
  }

  var invalidEntries = report.filter(function (entry) {
    return !entry.isValid;
  });
  if (invalidEntries.length > 0) {
    console.log('Invalid Entries');
    invalidEntries.forEach(function (entry) {
      console.log((entry.isValid ? 'valid' : 'invalid') + '\t' + entry.status + '\t' + (entry.threwError ? 'threw' : 'passed') + '\t' + entry.file);
    });
    process.exitCode = 1;
  }
  console.log('');
}

function run() {
  var parsed = getParser().parseArgs();
  main(resolveArgs(parsed, getPackageJsonArgs(parsed.root, DEFAULT_FLAGS)));
}

exports.run = run;
exports.getParser = getParser;
exports.main = main;
exports.resolveArgs = resolveArgs;